{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Laravel Job Status What does this package do? This package saves information about the jobs running in your Laravel application and lets you view realtime and historic data on what's going on in your queue. It also enhances jobs with two-way communication with your app, the ability to cancel jobs, and to save debug information. The frontend plugin provides users with instant feedback on background operations, with minimal configuration required. When should you use this package? If you would like an insight into your jobs and how they are performing, either for debugging or observation. If you need the ability to cancel jobs. If your users need real-time feedback on background jobs. Why should I use this package? This package shares a lot of features with Laravel Horizon, however Horizon is also a queue runner. This is excellent for a powerful no-fuss queue solution, but it means Horizon doesn't provide as much insight into your jobs. This package works well alongside Laravel Horizon, providing debugging on the jobs passing through Horizon and letting it handle the queue worker. Laravel provides job batches, which can provide feedback for users. However you have to scaffold this from scratch for every app you work on, and the information you can receive is limited and without the depth this package provides. Screenshots Instant user feedback In depth tracking Installation All you need to do to use this project is pull it into an existing Laravel app using composer. composer require twigger/laravel-job-status You can publish the configuration file by running php artisan vendor:publish --tag=laravel-job-status-config Demo site We've set up a demo site to dispatch fake jobs and see how this package tracks them. View it at (https://job-tracker.gpsvault.co.uk)[https://job-tracker.gpsvault.co.uk]. Quick-start guide Step 1 - Enable tracking for at least one job. Step 2 - View the history of the job. Step 3 - Give your users instant feedback.","title":"Getting Started"},{"location":"#laravel-job-status","text":"","title":"Laravel Job Status"},{"location":"#what-does-this-package-do","text":"This package saves information about the jobs running in your Laravel application and lets you view realtime and historic data on what's going on in your queue. It also enhances jobs with two-way communication with your app, the ability to cancel jobs, and to save debug information. The frontend plugin provides users with instant feedback on background operations, with minimal configuration required.","title":"What does this package do?"},{"location":"#when-should-you-use-this-package","text":"If you would like an insight into your jobs and how they are performing, either for debugging or observation. If you need the ability to cancel jobs. If your users need real-time feedback on background jobs.","title":"When should you use this package?"},{"location":"#why-should-i-use-this-package","text":"This package shares a lot of features with Laravel Horizon, however Horizon is also a queue runner. This is excellent for a powerful no-fuss queue solution, but it means Horizon doesn't provide as much insight into your jobs. This package works well alongside Laravel Horizon, providing debugging on the jobs passing through Horizon and letting it handle the queue worker. Laravel provides job batches, which can provide feedback for users. However you have to scaffold this from scratch for every app you work on, and the information you can receive is limited and without the depth this package provides.","title":"Why should I use this package?"},{"location":"#screenshots","text":"Instant user feedback In depth tracking","title":"Screenshots"},{"location":"#installation","text":"All you need to do to use this project is pull it into an existing Laravel app using composer. composer require twigger/laravel-job-status You can publish the configuration file by running php artisan vendor:publish --tag=laravel-job-status-config","title":"Installation"},{"location":"#demo-site","text":"We've set up a demo site to dispatch fake jobs and see how this package tracks them. View it at (https://job-tracker.gpsvault.co.uk)[https://job-tracker.gpsvault.co.uk].","title":"Demo site"},{"location":"#quick-start-guide","text":"Step 1 - Enable tracking for at least one job. Step 2 - View the history of the job. Step 3 - Give your users instant feedback.","title":"Quick-start guide"},{"location":"auth/","text":"Securing Jobs To prevent users accessing jobs they shouldn't be able to track, you can limit the history to only a select few users. Limiting job access Add a users method into your job that returns an array of user IDs. These users will be able to see the job status public function users(): array { return [$this->user->id]; } Public jobs If a user is not specified in users , they cannot view the job. By default, any user can view the job. Note If you have access to the job dashboard, you can see information about every job. The users array only controls who can access the job through your app, not through the dashboard. If a job should only be viewable to users granted access, it must be made private. Add an isUnprotected method to return false. public function isUnprotected(): bool { return false; } By default, a job is public/not protected. Resolving the current user When determining which jobs the user can view, we get the current user with Auth::user() . If your app is set up differently, you can change how we resolve the current user. In a service provider, add the following snippet. \\JobStatus\\JobStatusServiceProvider::$resolveAuthWith = function() { return Auth::user()->id; // Resolve the user ID however you'd like }","title":"Security"},{"location":"auth/#securing-jobs","text":"To prevent users accessing jobs they shouldn't be able to track, you can limit the history to only a select few users.","title":"Securing Jobs"},{"location":"auth/#limiting-job-access","text":"Add a users method into your job that returns an array of user IDs. These users will be able to see the job status public function users(): array { return [$this->user->id]; }","title":"Limiting job access"},{"location":"auth/#public-jobs","text":"If a user is not specified in users , they cannot view the job. By default, any user can view the job. Note If you have access to the job dashboard, you can see information about every job. The users array only controls who can access the job through your app, not through the dashboard. If a job should only be viewable to users granted access, it must be made private. Add an isUnprotected method to return false. public function isUnprotected(): bool { return false; } By default, a job is public/not protected.","title":"Public jobs"},{"location":"auth/#resolving-the-current-user","text":"When determining which jobs the user can view, we get the current user with Auth::user() . If your app is set up differently, you can change how we resolve the current user. In a service provider, add the following snippet. \\JobStatus\\JobStatusServiceProvider::$resolveAuthWith = function() { return Auth::user()->id; // Resolve the user ID however you'd like }","title":"Resolving the current user"},{"location":"clearing/","text":"Pruning Jobs If you have a lot of jobs, there's a potential for a lot of data to be collected. You should regularly prune this data. We provide a command to make this easy, but you should schedule it according to your needs. Prune command To prune all your jobs, run artisan job-status:clear . You can keep any job that's been updated recently. Pass in the --preserve option with the number of hours of jobs to keep. # Preserve the last 6 hours of jobs artisan job-status:clear --preserve = 6 Keeping failed jobs It is useful to keep failed jobs for longer than successful jobs, so you can debug any problems. With --keep-failed flag you can make sure no failed jobs are deleted. Trimming or deleting jobs To help build up analytics of your jobs, preserving more data is beneficial. To keep a high level overview of your job history, you can choose to just delete additional information about every job. This will remove information about messages, signals and past statuses, whilst preserving the core data. You will still be able to see the jobs contribution to your job insights, but will not be able to view the full job history. To turn on trimming, pass the --trim flag to the command. Wipe all data When developing laravel-job-status , or for other reasons - you might want to wipe all job status data from your database. To do this, pass the option --all , this will remove all constraints when searching for job status data to prune. Scheduling the command Often your real use case is more complex than the above examples. We may want to preserve a week of analytics at a time, and preserve failed jobs until you can debug them, but otherwise limit the stored data. To achieve this, we can schedule a combination of commands. // Trim any successful job older than 6 hours. $schedule->command('job-status:clear --preserve=6 --keep-failed --trim')->everyFifteenMinutes(); // Trim any failed job older than 2 days. $schedule->command('job-status:clear --preserve=48 --trim'); // Delete all jobs older than 1 week. $schedule->command('job-status:clear --preserve=168');","title":"Pruning"},{"location":"clearing/#pruning-jobs","text":"If you have a lot of jobs, there's a potential for a lot of data to be collected. You should regularly prune this data. We provide a command to make this easy, but you should schedule it according to your needs.","title":"Pruning Jobs"},{"location":"clearing/#prune-command","text":"To prune all your jobs, run artisan job-status:clear . You can keep any job that's been updated recently. Pass in the --preserve option with the number of hours of jobs to keep. # Preserve the last 6 hours of jobs artisan job-status:clear --preserve = 6","title":"Prune command"},{"location":"clearing/#keeping-failed-jobs","text":"It is useful to keep failed jobs for longer than successful jobs, so you can debug any problems. With --keep-failed flag you can make sure no failed jobs are deleted.","title":"Keeping failed jobs"},{"location":"clearing/#trimming-or-deleting-jobs","text":"To help build up analytics of your jobs, preserving more data is beneficial. To keep a high level overview of your job history, you can choose to just delete additional information about every job. This will remove information about messages, signals and past statuses, whilst preserving the core data. You will still be able to see the jobs contribution to your job insights, but will not be able to view the full job history. To turn on trimming, pass the --trim flag to the command.","title":"Trimming or deleting jobs"},{"location":"clearing/#wipe-all-data","text":"When developing laravel-job-status , or for other reasons - you might want to wipe all job status data from your database. To do this, pass the option --all , this will remove all constraints when searching for job status data to prune.","title":"Wipe all data"},{"location":"clearing/#scheduling-the-command","text":"Often your real use case is more complex than the above examples. We may want to preserve a week of analytics at a time, and preserve failed jobs until you can debug them, but otherwise limit the stored data. To achieve this, we can schedule a combination of commands. // Trim any successful job older than 6 hours. $schedule->command('job-status:clear --preserve=6 --keep-failed --trim')->everyFifteenMinutes(); // Trim any failed job older than 2 days. $schedule->command('job-status:clear --preserve=48 --trim'); // Delete all jobs older than 1 week. $schedule->command('job-status:clear --preserve=168');","title":"Scheduling the command"},{"location":"config/","text":"Configuration Publish the configuration file with artisan vendor:publish --tag=laravel-job-status-config . The configuration is documented in the configuration file generated by this command.","title":"Configuration"},{"location":"config/#configuration","text":"Publish the configuration file with artisan vendor:publish --tag=laravel-job-status-config . The configuration is documented in the configuration file generated by this command.","title":"Configuration"},{"location":"enable-tracking/","text":"Tracking a job Setting up tracking on Laravel jobs Basic Setup To set up tracking, simply add use Trackable; to your job class and make sure your job is queueable. Queues Jobs that are not added to the queue are not tracked, so make sure you implement \\Illuminate\\Contracts\\Queue\\ShouldQueue and use the \\Illuminate\\Bus\\Queueable trait. Job Alias This is a string unique to the job type (such as process-podcast ). This is essential if you use our frontend package, but is useful for understanding what jobs do at a glance. Tags You can also add tags, to help you find jobs in the future. These tags should let you identify the job uniquely, so will often include things like the user and any additional models the job uses. class ProcessPodcast { use Trackable; protected Podcast $podcast; public function handle() { // Upload and process the podcast } public function tags(): array { return [ 'podcast' => $this->podcast->id, ]; } public function alias(): string { return 'process-podcast'; } } Index-less tags You can provide an array of tags with numerical indexes from the tags function, for example public function tags(): array { return array_merge([ 'long-running', 'uses-third-party' ], [ 'podcast_id' => $this->podcast->id, 'user_id' => $this->user->id ]); } If you use Horizon, using index-less tags will let you continue to use the Horizon job tagging system. Warning Make sure your tags are different, ['podcast', 'podcast' => 1] is invalid. Tracking anonymous jobs By default, we only track the jobs that you tell us to (that use the Trackable trait). To track all jobs, set track_anonymous to true in your config . To make the results and debugging easier, we recommend setting up your job as above with some extra data and giving it access to features such as two-way communication.","title":"Enabling"},{"location":"enable-tracking/#tracking-a-job","text":"Setting up tracking on Laravel jobs","title":"Tracking a job"},{"location":"enable-tracking/#basic-setup","text":"To set up tracking, simply add use Trackable; to your job class and make sure your job is queueable. Queues Jobs that are not added to the queue are not tracked, so make sure you implement \\Illuminate\\Contracts\\Queue\\ShouldQueue and use the \\Illuminate\\Bus\\Queueable trait.","title":"Basic Setup"},{"location":"enable-tracking/#job-alias","text":"This is a string unique to the job type (such as process-podcast ). This is essential if you use our frontend package, but is useful for understanding what jobs do at a glance.","title":"Job Alias"},{"location":"enable-tracking/#tags","text":"You can also add tags, to help you find jobs in the future. These tags should let you identify the job uniquely, so will often include things like the user and any additional models the job uses. class ProcessPodcast { use Trackable; protected Podcast $podcast; public function handle() { // Upload and process the podcast } public function tags(): array { return [ 'podcast' => $this->podcast->id, ]; } public function alias(): string { return 'process-podcast'; } }","title":"Tags"},{"location":"enable-tracking/#index-less-tags","text":"You can provide an array of tags with numerical indexes from the tags function, for example public function tags(): array { return array_merge([ 'long-running', 'uses-third-party' ], [ 'podcast_id' => $this->podcast->id, 'user_id' => $this->user->id ]); } If you use Horizon, using index-less tags will let you continue to use the Horizon job tagging system. Warning Make sure your tags are different, ['podcast', 'podcast' => 1] is invalid.","title":"Index-less tags"},{"location":"enable-tracking/#tracking-anonymous-jobs","text":"By default, we only track the jobs that you tell us to (that use the Trackable trait). To track all jobs, set track_anonymous to true in your config . To make the results and debugging easier, we recommend setting up your job as above with some extra data and giving it access to features such as two-way communication.","title":"Tracking anonymous jobs"},{"location":"advanced/php-history/","text":"Interacting with job history in your code Although you can make use of the API in this package, you may find yourself needing something more advanced and custom to your use case. You can access the job history through your app with our intuitive search results. Searching for job history Searching for job tracking is done using Eloquent. Query the \\JobStatus\\Models\\JobStatus model - each of these models represents a job that has been queued or ran. To make it easier, we've provided some scopes. whereClass($jobClass) - Filter by the job class (.e.g \\App\\Jobs\\ProcessPodcast ) whereAlias($jobAlias) - Filter by the job alias whereTag($key, $value) - Filter by a tag. Leave the value blank to search for index-less tags. whereTags(['key' => 'value']) - Filter by multiple tags in a key-value array whereHasTag('key1') - Filter to jobs that have a tag, with any or no value. whereHasTags(['key1', 'key2']) - Filter by multiple tags existing whereFinished() - Filter to jobs that have finished running whereNotFinished() - Filter to jobs that are running or queued whereStatusIn([\\JobStatus\\Enums\\Status::SUCCEEDED]) - Filter to jobs with the given statuses whereStatusNotIn([\\JobStatus\\Enums\\Status::FAILED]) - Filter to jobs without the given statuses whereUuid($uuid) - Filter to jobs with a matching uuid forUsers(1) - Filter to jobs that allows the given use to access it. This will also match all unprotected jobs. Index-less If you use index-less tags, omit the value in whereTag and pass the value into whereHasTag ; ->whereTag('long-running') ->whereHasTag('long-running') Drilling into results Once you have a collection of JobStatus models, you can make use of some handy macros Jobs Calling jobs() gets you an array of \\JobStatus\\Search\\Results\\TrackedJob . This contains information about the job itself, including analytics about previous runs. Batches Calling batches() gets you an array of \\JobStatus\\Search\\Results\\Batch . This contains information about the batch the jobs ran in. It will discard any results not in a batch. Queues Calling queues() gets you an array of \\JobStatus\\Search\\Results\\Queue . This contains information about the queue the jobs ran in. Runs Calling runs() converts the models into instances of a \\JobStatus\\Search\\Results\\JobRun class. This has handy tools to help you interact with the run, and groups retries together so that you only see the latest runs and any retries are stored in the latest run. Methods available Tracked Job Represents a job class itself. Contains information about the job and about the previous times the job has ran. jobClass() - The class of the job alias() - The alias of the job numberOfRuns() - The number of runs made countWithStatus(Status $status) - How many jobs have the given status getFailureReasons() - Get a list of reasons why the job has failed in the past Batch batchId() - The ID of the batch. numberOfRuns() - Count how many runs are in the batch name() - The name of the batch. countWithStatus($status) - Count how many runs are in the batch with the given status Queue name() - The name of the queue. numberOfRuns() - Count how many runs are in the queue countWithStatus($status) - Count how many runs are in the queue with the given status Job Run Each job run is a new time a job has been dispatched Job Information getTagsAsArray() - Get the tags belonging to a job in a [key => value] format. getPercentge() : Get the status of the job. accessibleBy($userId) - Check if the given user ID can access the job trackingIsUnprotected() - True if the tracking is marked as public/not protected Granting Access To grant access to additional users beyond those listed in the job , call $run->modifier()->grantAccessTo(int $userId) and pass in the ID of the user. Status A job has one of the following statuses (in the enum \\App\\Enums\\Status ). - queued - started - succeeded - cancelled - failed $run->getStatus() : Get the status of the job. $run->isSuccessful() : True if the job was a success $run->isRunning() : True if the job was a success $run->isQueued() : True if the job was a success $run->isCancelled() : True if the job was a success $run->isFailed() : True if the job was a success $run->isFinished() : True if the job is no longer running. Messages $run->messages() - Get an array of messages that were sent. $run->mostRecentMessage(includeDebug: true) - Get the most recent message that was sent. $run->messagesOfType('error') - Get all messages of the given type. Signals $run->signals() - Get an array of signals that were sent. Sending signals Using the modifier() option on the job run, you can interact with the job. $run->modifier()->cancel() - Cancel the job run. $run->modifier->sendSignal(string $signal, array $parameters, bool $cancelJob = false) - Send a custom signal to the job. Retries If the run was retried, you can access its parent. This is the run that failed and caused the job to be retried. $jobRun->hasParent() - Check if the job has a parent. $jobRun->isARetry() - Check if the job is a retry of a failed job. $jobRun->parent() - Get the parent of this job. Exception If an exception was thrown, you can access it through $jobRun->getException() .","title":"Interacting with history programmatically"},{"location":"advanced/php-history/#interacting-with-job-history-in-your-code","text":"Although you can make use of the API in this package, you may find yourself needing something more advanced and custom to your use case. You can access the job history through your app with our intuitive search results.","title":"Interacting with job history in your code"},{"location":"advanced/php-history/#searching-for-job-history","text":"Searching for job tracking is done using Eloquent. Query the \\JobStatus\\Models\\JobStatus model - each of these models represents a job that has been queued or ran. To make it easier, we've provided some scopes. whereClass($jobClass) - Filter by the job class (.e.g \\App\\Jobs\\ProcessPodcast ) whereAlias($jobAlias) - Filter by the job alias whereTag($key, $value) - Filter by a tag. Leave the value blank to search for index-less tags. whereTags(['key' => 'value']) - Filter by multiple tags in a key-value array whereHasTag('key1') - Filter to jobs that have a tag, with any or no value. whereHasTags(['key1', 'key2']) - Filter by multiple tags existing whereFinished() - Filter to jobs that have finished running whereNotFinished() - Filter to jobs that are running or queued whereStatusIn([\\JobStatus\\Enums\\Status::SUCCEEDED]) - Filter to jobs with the given statuses whereStatusNotIn([\\JobStatus\\Enums\\Status::FAILED]) - Filter to jobs without the given statuses whereUuid($uuid) - Filter to jobs with a matching uuid forUsers(1) - Filter to jobs that allows the given use to access it. This will also match all unprotected jobs. Index-less If you use index-less tags, omit the value in whereTag and pass the value into whereHasTag ; ->whereTag('long-running') ->whereHasTag('long-running')","title":"Searching for job history"},{"location":"advanced/php-history/#drilling-into-results","text":"Once you have a collection of JobStatus models, you can make use of some handy macros","title":"Drilling into results"},{"location":"advanced/php-history/#jobs","text":"Calling jobs() gets you an array of \\JobStatus\\Search\\Results\\TrackedJob . This contains information about the job itself, including analytics about previous runs.","title":"Jobs"},{"location":"advanced/php-history/#batches","text":"Calling batches() gets you an array of \\JobStatus\\Search\\Results\\Batch . This contains information about the batch the jobs ran in. It will discard any results not in a batch.","title":"Batches"},{"location":"advanced/php-history/#queues","text":"Calling queues() gets you an array of \\JobStatus\\Search\\Results\\Queue . This contains information about the queue the jobs ran in.","title":"Queues"},{"location":"advanced/php-history/#runs","text":"Calling runs() converts the models into instances of a \\JobStatus\\Search\\Results\\JobRun class. This has handy tools to help you interact with the run, and groups retries together so that you only see the latest runs and any retries are stored in the latest run.","title":"Runs"},{"location":"advanced/php-history/#methods-available","text":"","title":"Methods available"},{"location":"advanced/php-history/#tracked-job","text":"Represents a job class itself. Contains information about the job and about the previous times the job has ran. jobClass() - The class of the job alias() - The alias of the job numberOfRuns() - The number of runs made countWithStatus(Status $status) - How many jobs have the given status getFailureReasons() - Get a list of reasons why the job has failed in the past","title":"Tracked Job"},{"location":"advanced/php-history/#batch","text":"batchId() - The ID of the batch. numberOfRuns() - Count how many runs are in the batch name() - The name of the batch. countWithStatus($status) - Count how many runs are in the batch with the given status","title":"Batch"},{"location":"advanced/php-history/#queue","text":"name() - The name of the queue. numberOfRuns() - Count how many runs are in the queue countWithStatus($status) - Count how many runs are in the queue with the given status","title":"Queue"},{"location":"advanced/php-history/#job-run","text":"Each job run is a new time a job has been dispatched","title":"Job Run"},{"location":"advanced/php-history/#job-information","text":"getTagsAsArray() - Get the tags belonging to a job in a [key => value] format. getPercentge() : Get the status of the job. accessibleBy($userId) - Check if the given user ID can access the job trackingIsUnprotected() - True if the tracking is marked as public/not protected","title":"Job Information"},{"location":"advanced/php-history/#granting-access","text":"To grant access to additional users beyond those listed in the job , call $run->modifier()->grantAccessTo(int $userId) and pass in the ID of the user.","title":"Granting Access"},{"location":"advanced/php-history/#status","text":"A job has one of the following statuses (in the enum \\App\\Enums\\Status ). - queued - started - succeeded - cancelled - failed $run->getStatus() : Get the status of the job. $run->isSuccessful() : True if the job was a success $run->isRunning() : True if the job was a success $run->isQueued() : True if the job was a success $run->isCancelled() : True if the job was a success $run->isFailed() : True if the job was a success $run->isFinished() : True if the job is no longer running.","title":"Status"},{"location":"advanced/php-history/#messages","text":"$run->messages() - Get an array of messages that were sent. $run->mostRecentMessage(includeDebug: true) - Get the most recent message that was sent. $run->messagesOfType('error') - Get all messages of the given type.","title":"Messages"},{"location":"advanced/php-history/#signals","text":"$run->signals() - Get an array of signals that were sent.","title":"Signals"},{"location":"advanced/php-history/#sending-signals","text":"Using the modifier() option on the job run, you can interact with the job. $run->modifier()->cancel() - Cancel the job run. $run->modifier->sendSignal(string $signal, array $parameters, bool $cancelJob = false) - Send a custom signal to the job.","title":"Sending signals"},{"location":"advanced/php-history/#retries","text":"If the run was retried, you can access its parent. This is the run that failed and caused the job to be retried. $jobRun->hasParent() - Check if the job has a parent. $jobRun->isARetry() - Check if the job is a retry of a failed job. $jobRun->parent() - Get the parent of this job.","title":"Retries"},{"location":"advanced/php-history/#exception","text":"If an exception was thrown, you can access it through $jobRun->getException() .","title":"Exception"},{"location":"dashboard/batches/","text":"Viewing Batches Listing batches You can see a list of batches in your app Viewing batches Clicking on the batch shows you the jobs inside it, as well as some data about the batch.","title":"Viewing Batches"},{"location":"dashboard/batches/#viewing-batches","text":"","title":"Viewing Batches"},{"location":"dashboard/batches/#listing-batches","text":"You can see a list of batches in your app","title":"Listing batches"},{"location":"dashboard/batches/#viewing-batches_1","text":"Clicking on the batch shows you the jobs inside it, as well as some data about the batch.","title":"Viewing batches"},{"location":"dashboard/installing/","text":"Job Dashboard The job dashboard drills down into your job history and shows you analytics alongside in-depth information about runs. To install the required javascript to make the dashboard run, run artisan job:install . You can then access the dashboard at /job-status Keeping assets up to date To keep the js assets up to date, you should run artisan job:install after every update of the package. To automate this, add it to your composer.json file. { \"scripts\" : { \"post-update-cmd\" : [ \"@php artisan job:install\" ] } } Auth Only users with the viewJobStatus permission can access the dashboard. You can define these users by defining a Laravel Gate. namespace App\\Providers; use Illuminate\\Support\\Facades\\Gate; class AuthServiceProvider extends ServiceProvider { public function boot() { Gate::define('viewJobStatus', function(User $user) { return $user->isAdmin(); }); } } By default, the dashboard can be accessed locally.","title":"Installing"},{"location":"dashboard/installing/#job-dashboard","text":"The job dashboard drills down into your job history and shows you analytics alongside in-depth information about runs. To install the required javascript to make the dashboard run, run artisan job:install . You can then access the dashboard at /job-status","title":"Job Dashboard"},{"location":"dashboard/installing/#keeping-assets-up-to-date","text":"To keep the js assets up to date, you should run artisan job:install after every update of the package. To automate this, add it to your composer.json file. { \"scripts\" : { \"post-update-cmd\" : [ \"@php artisan job:install\" ] } }","title":"Keeping assets up to date"},{"location":"dashboard/installing/#auth","text":"Only users with the viewJobStatus permission can access the dashboard. You can define these users by defining a Laravel Gate. namespace App\\Providers; use Illuminate\\Support\\Facades\\Gate; class AuthServiceProvider extends ServiceProvider { public function boot() { Gate::define('viewJobStatus', function(User $user) { return $user->isAdmin(); }); } } By default, the dashboard can be accessed locally.","title":"Auth"},{"location":"dashboard/jobs/","text":"Viewing Jobs Listing Jobs At /job-status#/jobs , you can see a list of all jobs that have been dispatched before, along with some basic analytics. Viewing a Job Clicking on a job shows you more in depth information about it, and all the runs the job has had.","title":"Viewing Jobs"},{"location":"dashboard/jobs/#viewing-jobs","text":"","title":"Viewing Jobs"},{"location":"dashboard/jobs/#listing-jobs","text":"At /job-status#/jobs , you can see a list of all jobs that have been dispatched before, along with some basic analytics.","title":"Listing Jobs"},{"location":"dashboard/jobs/#viewing-a-job","text":"Clicking on a job shows you more in depth information about it, and all the runs the job has had.","title":"Viewing a Job"},{"location":"dashboard/queues/","text":"Viewing Queues Listing queues You can see a list of queues that your app is running Viewing queues Clicking on the queue shows you the jobs inside it, as well as some data about the queue.","title":"Viewing Queues"},{"location":"dashboard/queues/#viewing-queues","text":"","title":"Viewing Queues"},{"location":"dashboard/queues/#listing-queues","text":"You can see a list of queues that your app is running","title":"Listing queues"},{"location":"dashboard/queues/#viewing-queues_1","text":"Clicking on the queue shows you the jobs inside it, as well as some data about the queue.","title":"Viewing queues"},{"location":"dashboard/runs/","text":"Viewing a Run Selecting retries By default you will see the latest run. If this run was started when it previously failed, e.g. it is a retry, you can see and select which run you would like to view from the top. See run information You can see a list of run information Run timeline The timeline will list Any status changes Any messages sent Any signals sent or received Any errors Exceptions You can dive into the exception thrown by a failed job Cancelling & Retrying You can cancel and/or retry a job by clicking the button in the corner.","title":"Viewing Runs"},{"location":"dashboard/runs/#viewing-a-run","text":"","title":"Viewing a Run"},{"location":"dashboard/runs/#selecting-retries","text":"By default you will see the latest run. If this run was started when it previously failed, e.g. it is a retry, you can see and select which run you would like to view from the top.","title":"Selecting retries"},{"location":"dashboard/runs/#see-run-information","text":"You can see a list of run information","title":"See run information"},{"location":"dashboard/runs/#run-timeline","text":"The timeline will list Any status changes Any messages sent Any signals sent or received Any errors","title":"Run timeline"},{"location":"dashboard/runs/#exceptions","text":"You can dive into the exception thrown by a failed job","title":"Exceptions"},{"location":"dashboard/runs/#cancelling-retrying","text":"You can cancel and/or retry a job by clicking the button in the corner.","title":"Cancelling &amp; Retrying"},{"location":"dashboard/security/","text":"Security Access to the job status dashboard should be protected - by default it's only accessible in the local environment. Add the following to define users that can access the dashboard. \\Gate::define('viewJobStatus', function ($user) { return in_array($user->email, [ // A list of email addresses that have access ]); });","title":"Security"},{"location":"dashboard/security/#security","text":"Access to the job status dashboard should be protected - by default it's only accessible in the local environment. Add the following to define users that can access the dashboard. \\Gate::define('viewJobStatus', function ($user) { return in_array($user->email, [ // A list of email addresses that have access ]); });","title":"Security"},{"location":"features/messages/","text":"Messages Messages are bits of text that contain information about what a job is doing. These let your users see informative information about the task being processed. Sending messages To send a message, you can call $this->status()->line('3/10 emails sent.'); within your job. You can also set a type on a message. A type is one of success, error, info (the default), warning or debug. Call $this->status()->message('All emails sent successfully.', 'success') to set a message with a type. There are also aliases you can use such as successMessage , warningMessage etc. class PlanRoute { public function handle() { $this->status()->line('Planning public transport route'); $this->planner->planPublicTransportRoute(); $this->status()->line('Planning driving route'); $this->planner->planDrivingRoute(); $this->status()->line('Planning cycling route'); $this->planner->planCyclingRoute(); $this->status()->line('Planning walking route'); $this->planner->planWalkingRoute(); $this->successMessage('All routes planned'); } }","title":"Sending messages"},{"location":"features/messages/#messages","text":"Messages are bits of text that contain information about what a job is doing. These let your users see informative information about the task being processed.","title":"Messages"},{"location":"features/messages/#sending-messages","text":"To send a message, you can call $this->status()->line('3/10 emails sent.'); within your job. You can also set a type on a message. A type is one of success, error, info (the default), warning or debug. Call $this->status()->message('All emails sent successfully.', 'success') to set a message with a type. There are also aliases you can use such as successMessage , warningMessage etc. class PlanRoute { public function handle() { $this->status()->line('Planning public transport route'); $this->planner->planPublicTransportRoute(); $this->status()->line('Planning driving route'); $this->planner->planDrivingRoute(); $this->status()->line('Planning cycling route'); $this->planner->planCyclingRoute(); $this->status()->line('Planning walking route'); $this->planner->planWalkingRoute(); $this->successMessage('All routes planned'); } }","title":"Sending messages"},{"location":"features/progress/","text":"Progress Your job can let the rest of your application know how far through processing it is. This isn't always possible, so by default the percentage will be set to 100% when the job is finished. If you are able to track the percentage completion of your job, call $this->percentage($progressValue) within the handle method of your job. Examples Not possible to use percentages In this example we can't set the percentage information, since we can't track the long running part of the job. We can rely on the default behaviour to show 100% to the user when the job is complete. class SendEmail { public function handle() { $this->email->send(); } } Can use percentages In this example we are set the percentage information, since we are iterating through a defined number of objects and so can calculate how far through we are. class SendEmail { public function handle() { foreach($this->users as $index => $user) { $percentageValue = $this->generatePercentage($index); $this->status()->setPercentage($percentageValue); $this->email->sendTo($user); } } private function generatePercentage($index): int { return ($index/$this->users->count()) * 100 } }","title":"Progress"},{"location":"features/progress/#progress","text":"Your job can let the rest of your application know how far through processing it is. This isn't always possible, so by default the percentage will be set to 100% when the job is finished. If you are able to track the percentage completion of your job, call $this->percentage($progressValue) within the handle method of your job.","title":"Progress"},{"location":"features/progress/#examples","text":"","title":"Examples"},{"location":"features/progress/#not-possible-to-use-percentages","text":"In this example we can't set the percentage information, since we can't track the long running part of the job. We can rely on the default behaviour to show 100% to the user when the job is complete. class SendEmail { public function handle() { $this->email->send(); } }","title":"Not possible to use percentages"},{"location":"features/progress/#can-use-percentages","text":"In this example we are set the percentage information, since we are iterating through a defined number of objects and so can calculate how far through we are. class SendEmail { public function handle() { foreach($this->users as $index => $user) { $percentageValue = $this->generatePercentage($index); $this->status()->setPercentage($percentageValue); $this->email->sendTo($user); } } private function generatePercentage($index): int { return ($index/$this->users->count()) * 100 } }","title":"Can use percentages"},{"location":"features/signals/","text":"Signals Signals are the opposite of messages - they let your app communicate with your job. Cancelling a job Once you've dispatched a job, you are able to cancel it at a later date. This can be done through the dashboard , programatically or through the JS API client . Enabling cancelling Cancelling a job is not a first party feature in Laravel. Within a long-running job, you will need to tell this package when a cancellation can happen. If the user has sent the cancellation signal you can run some cleanup code to clean up anything your job may have done. public function handle() { foreach($i = 0; $i<10;$i++) { $this->status()->line('Processing number ' . $i); $this->checkForSignals(); // Check if the user has cancelled the job } public function onCancel() { // Clean up code to run if the job is cancelled. } } If a user cancels this job before it is complete, the checkForSignals function will cancel the job and clean up any side effects by calling the onCancel method. Custom Signals Cancelling a job is one example of a signal, where the app is sending a message to the job. You can have any number of custom signals to help your app run smoothly. For example, you may signal the job when a new job is added, so you can stop or limit operation of the original job. Sending Signals This can be done programatically or through the JS API client . Signal parameters With custom signals, you can also send parameters to the job. For example, a job that checks the price of all the books a user owns may want to be notified if a new book is added during processing. To avoid us having to redo all the books, the signal can contain information about the new book allowing us to add it to the queue. $jobRun->modifier()->sendSignal('book-added', ['book_id' => $bookId]); ```` ```php class CheckBookPrice { protected Collection $books; public function handle() { foreach($this->books as $bookId) { $this->priceChecker->checkFor($bookId) $this->checkForSignals(); } } public function onBookAdded($parameters) { $this->books->push($parameters['book_id']); } public function tags(): array { return ['user_id' => $this->user->id]; } public function alias(): string { return 'check-book-price'; } } Checking for signals To make your job respond to these signals, you can add onSignalName methods, which will be executed when the signal is received. It's important to note that you need to regularly call $this->checkSignals() in your job to let this package check the status of any signals. class MyJob { public function handle() { foreach($i = 0; $i<10;$i++) { $this->checkForSignals(); } } public function onCancel() { // Code to clean up the job. } public function onUserLoggedOut() { // Code to execute when we receive a 'user-logged-out' signal. } } Stopping jobs If you want to stop your job on being sent a signal, you have two choices. You can throw an exception in the onSignalName method, which will mark your job as a failure. Or you can pass cancelJob: true to the sendSignal function to cancel the job after the cleanup has finished. $jobRun->modifier()->sendSignal('user-deleted', ['user_id' => $user->id], cancelJob: true);","title":"Signals"},{"location":"features/signals/#signals","text":"Signals are the opposite of messages - they let your app communicate with your job.","title":"Signals"},{"location":"features/signals/#cancelling-a-job","text":"Once you've dispatched a job, you are able to cancel it at a later date. This can be done through the dashboard , programatically or through the JS API client .","title":"Cancelling a job"},{"location":"features/signals/#enabling-cancelling","text":"Cancelling a job is not a first party feature in Laravel. Within a long-running job, you will need to tell this package when a cancellation can happen. If the user has sent the cancellation signal you can run some cleanup code to clean up anything your job may have done. public function handle() { foreach($i = 0; $i<10;$i++) { $this->status()->line('Processing number ' . $i); $this->checkForSignals(); // Check if the user has cancelled the job } public function onCancel() { // Clean up code to run if the job is cancelled. } } If a user cancels this job before it is complete, the checkForSignals function will cancel the job and clean up any side effects by calling the onCancel method.","title":"Enabling cancelling"},{"location":"features/signals/#custom-signals","text":"Cancelling a job is one example of a signal, where the app is sending a message to the job. You can have any number of custom signals to help your app run smoothly. For example, you may signal the job when a new job is added, so you can stop or limit operation of the original job.","title":"Custom Signals"},{"location":"features/signals/#sending-signals","text":"This can be done programatically or through the JS API client .","title":"Sending Signals"},{"location":"features/signals/#signal-parameters","text":"With custom signals, you can also send parameters to the job. For example, a job that checks the price of all the books a user owns may want to be notified if a new book is added during processing. To avoid us having to redo all the books, the signal can contain information about the new book allowing us to add it to the queue. $jobRun->modifier()->sendSignal('book-added', ['book_id' => $bookId]); ```` ```php class CheckBookPrice { protected Collection $books; public function handle() { foreach($this->books as $bookId) { $this->priceChecker->checkFor($bookId) $this->checkForSignals(); } } public function onBookAdded($parameters) { $this->books->push($parameters['book_id']); } public function tags(): array { return ['user_id' => $this->user->id]; } public function alias(): string { return 'check-book-price'; } }","title":"Signal parameters"},{"location":"features/signals/#checking-for-signals","text":"To make your job respond to these signals, you can add onSignalName methods, which will be executed when the signal is received. It's important to note that you need to regularly call $this->checkSignals() in your job to let this package check the status of any signals. class MyJob { public function handle() { foreach($i = 0; $i<10;$i++) { $this->checkForSignals(); } } public function onCancel() { // Code to clean up the job. } public function onUserLoggedOut() { // Code to execute when we receive a 'user-logged-out' signal. } }","title":"Checking for signals"},{"location":"features/signals/#stopping-jobs","text":"If you want to stop your job on being sent a signal, you have two choices. You can throw an exception in the onSignalName method, which will mark your job as a failure. Or you can pass cancelJob: true to the sendSignal function to cancel the job after the cleanup has finished. $jobRun->modifier()->sendSignal('user-deleted', ['user_id' => $user->id], cancelJob: true);","title":"Stopping jobs"},{"location":"js/js/","text":"JavaScript This package provides an API for you to show the progress of a job to your users. We've also created a Javascript client that makes it trivial to connect to your application and track jobs. Installation To install the frontend package, you can use npm or yarn . npm install --save @tobytwigger/laravel-job-status-js yarn add @tobytwigger/laravel-job-status-js You will also need to share configuration with this package. To do this, add @jobapi into the blade template of any page that uses the config. Using the client A request has two steps - building up the request with any filters or pagination information, and telling the client if you want the result to be kept up to date. Using either polling or websockets, we can keep any API result up to date to show your users realtime information. Sending a basic request To build up a request Choose the type of object you want to work with Choose the type of request to make Provide any parameters import { client } from '@tobytwigger/laravel-job-status-js' ; client . runs . search (). whereStatus ( 'failed' ). send () . then ( response => console . log ( 'Number of failed runs: ' + response . data . length )); See the appendix for all available methods. Listening for updates Calling .send() gets the result in a promise as usual. To keep the result up to date, and therefore let your users see the job progress updating, we can listen to the result. Usually this just instructs the client to poll the API every few seconds, but it can make use of webhooks in some situations. Provide callbacks to listen() to keep information up to date let isLoadingInitialResult = false ; let isUpdating = false ; let results = []; let listener = client . runs . search (). whereStatus ( 'failed' ). listen () // Show the user a large loading screen when we're initially loading job information. . onStartingInitialLoad (() => isLoadingInitialResult = true ) . onFinishingInitialLoad (() => isLoadingInitialResult = false ) // When we're just updating the information, show a small loading wheel in the corner of the screen. . onStartingUpdate (() => isUpdating = true ) . onFinishingUpdate (() => isUpdating = false ) // Save the results when updated . onUpdated ( newResults => results = newResults ) // Log any errors. . onErrored ( error => console . log ( error )) . start (); results will now contain up to date information. The returned listener is essential for cleaning up and avoiding excess requests. Cleaning Up When the user navigates away from the code, you'll want to stop the client from listening. When you call start() , you get back a listener. Call listener.stop() to cancel any requests and stop the listening. Available methods Runs Interact with times that your jobs have ran Search for runs Request Response client . runs . search () . whereAlias ( 'job-alias' ) // Optional call to filter by alias. Can be called multiple times. . whereStatus ( 'failed' ) // Optional call to filter by status. Can be called multiple times. . send (); [{ alias : string ; // The alias of your job. class : string ; // The class of the job. percentage : number ; // The percentage of the way through the job we are. status : string ; // The status of the job. uuid : string ; // The UUID Laravel assigned to the job. parent : {...} | null ; // The parent of the job. This is filled in if a job failed and this is the retry. It has the same structure as this data structure. created_at : Date ; // When was the job status created. This is always the order in which the runs were queued. messages : [ // Any messages sent in the job { message : string ; // The message type : MessageType ; // The type of the message } ]; signals : [ // Signals sent to the job { signal : string ; // The signal sent created_at : Date ; // When the signal was sent handled_at : Date ; // When the signal was handled cancel_job : boolean ; // If the signal will/did cause the job to stop parameters : { key : value // User-defined parameters in the signal }; } ]; exception : { // The exception that caused the job to fail, or null if not an exception id : number ; // An ID for the exception previous : JobException | null ; // The previous thrown exception, or null if only one exception was thrown message : string ; // The exception message line : number ; // The line the error occurred on file : string ; // The file the error occurred in code : number ; // The code of the exception stack_trace : []; // The stack trace }; statuses : [ // A history of status changes for the job { status : Status ; // The status created_at : Date ; // When the status was set } ]; started_at : Date | null ; // When the job started processing finished_at : Date | null ; // When the job finished processing batch_id : number ; // The ID of the batch batch_id_uuid : string ; // The UUID of the batch that Laravel assigned id : number ; // An ID for the run tags : { // A list of tags the job has applied key : value }; has_payload : boolean ; // Whether we've stored the payload of the job connection_name : string | null ; // The name of the connection the job is stored on queue : string | null ; // The queue the job is in released_runs : [{...}] // Any times this run ran but was stopped by rate limiting middleware. This is an array of runs with the same structure as this data structure. }] Get a run by ID Request Response client . runs . show ( 44 ) . send (); { alias : string ; // The alias of your job. class : string ; // The class of the job. percentage : number ; // The percentage of the way through the job we are. status : string ; // The status of the job. uuid : string ; // The UUID Laravel assigned to the job. parent : {...} | null ; // The parent of the job. This is filled in if a job failed and this is the retry. It has the same structure as this data structure. created_at : Date ; // When was the job status created. This is always the order in which the runs were queued. messages : [ // Any messages sent in the job { message : string ; // The message type : MessageType ; // The type of the message } ]; signals : [ // Signals sent to the job { signal : string ; // The signal sent created_at : Date ; // When the signal was sent handled_at : Date ; // When the signal was handled cancel_job : boolean ; // If the signal will/did cause the job to stop parameters : { key : value // User-defined parameters in the signal }; } ]; exception : { // The exception that caused the job to fail, or null if not an exception id : number ; // An ID for the exception previous : JobException | null ; // The previous thrown exception, or null if only one exception was thrown message : string ; // The exception message line : number ; // The line the error occurred on file : string ; // The file the error occurred in code : number ; // The code of the exception stack_trace : []; // The stack trace }; statuses : [ // A history of status changes for the job { status : Status ; // The status created_at : Date ; // When the status was set } ]; started_at : Date | null ; // When the job started processing finished_at : Date | null ; // When the job finished processing batch_id : number ; // The ID of the batch batch_id_uuid : string ; // The UUID of the batch that Laravel assigned id : number ; // An ID for the run tags : { // A list of tags the job has applied key : value }; has_payload : boolean ; // Whether we've stored the payload of the job connection_name : string | null ; // The name of the connection the job is stored on queue : string | null ; // The queue the job is in } Retry a run Request Response client . runs . retry ( 44 ) . send (); {} Send a signal Request Response client . runs . signal ( jobStatusId : number , // The ID of the run model signal : string , // The signal to send, e.g. 'cancel' cancel : boolean , // Whether to cancel the job when the signal runs. parameters : { key : value } // Parameters to pass to the job through the signal ) . send (); {} Jobs Interact with the jobs in your Laravel app Search for jobs Request Response client . jobs . search () . send (); [{ class : string ; // The class of the job alias : string ; // The alias of the job count : number ; // The number of times this job has ran successful : number ; // The number of successful jobs failed : number ; // The number of failed jobs started : number ; // The number of started jobs queued : number ; // The number of queued jobs cancelled : number ; // The number of cancelled jobs failure_reasons : [ // The reasons the job has failed { message : 'Your error message' , count : 10 } ]; }] See the Run Show documentation for the structure of the job run Show a job by alias/class Request Response client . jobs . show ( 'my-job-alias-or-class' ) // Pass the job alias or the job class to retrieve the job. . send (); { class : string ; // The class of the job alias : string ; // The alias of the job count : number ; // The number of times this job has ran successful : number ; // The number of successful jobs failed : number ; // The number of failed jobs started : number ; // The number of started jobs queued : number ; // The number of queued jobs cancelled : number ; // The number of cancelled jobs failure_reasons : [ // The reasons the job has failed { message : 'Your error message' , count : 10 } ]; } See the Run Show documentation for the structure of the job run Batches Retrieve information about the batches that have ran through your queue system Search for batches Request Response client . batches . search () . send (); [{ count : number ; // The number of jobs in this batch batch_id : string ; // The UUID of this batch that Laravel assigned name : string | null ; // The name of this batch created_at : Date ; // When this batch was created queued : number ; // How many runs in the batch are queued started : number ; // How many runs in the batch are started failed : number ; // How many runs in the batch are failed succeeded : number ; // How many runs in the batch are succeeded cancelled : number ; // How many runs in the batch are cancelled }] Get a batch by ID Request Response client . batches . show ( 24 ) // This is the ID of the batch from this package, and not the UUID. . send (); { count : number ; // The number of jobs in this batch batch_id : string ; // The UUID of this batch that Laravel assigned name : string | null ; // The name of this batch created_at : Date ; // When this batch was created queued : number ; // How many runs in the batch are queued started : number ; // How many runs in the batch are started failed : number ; // How many runs in the batch are failed succeeded : number ; // How many runs in the batch are succeeded cancelled : number ; // How many runs in the batch are cancelled }","title":"Javascript"},{"location":"js/js/#javascript","text":"This package provides an API for you to show the progress of a job to your users. We've also created a Javascript client that makes it trivial to connect to your application and track jobs.","title":"JavaScript"},{"location":"js/js/#installation","text":"To install the frontend package, you can use npm or yarn . npm install --save @tobytwigger/laravel-job-status-js yarn add @tobytwigger/laravel-job-status-js You will also need to share configuration with this package. To do this, add @jobapi into the blade template of any page that uses the config.","title":"Installation"},{"location":"js/js/#using-the-client","text":"A request has two steps - building up the request with any filters or pagination information, and telling the client if you want the result to be kept up to date. Using either polling or websockets, we can keep any API result up to date to show your users realtime information.","title":"Using the client"},{"location":"js/js/#sending-a-basic-request","text":"To build up a request Choose the type of object you want to work with Choose the type of request to make Provide any parameters import { client } from '@tobytwigger/laravel-job-status-js' ; client . runs . search (). whereStatus ( 'failed' ). send () . then ( response => console . log ( 'Number of failed runs: ' + response . data . length )); See the appendix for all available methods.","title":"Sending a basic request"},{"location":"js/js/#listening-for-updates","text":"Calling .send() gets the result in a promise as usual. To keep the result up to date, and therefore let your users see the job progress updating, we can listen to the result. Usually this just instructs the client to poll the API every few seconds, but it can make use of webhooks in some situations. Provide callbacks to listen() to keep information up to date let isLoadingInitialResult = false ; let isUpdating = false ; let results = []; let listener = client . runs . search (). whereStatus ( 'failed' ). listen () // Show the user a large loading screen when we're initially loading job information. . onStartingInitialLoad (() => isLoadingInitialResult = true ) . onFinishingInitialLoad (() => isLoadingInitialResult = false ) // When we're just updating the information, show a small loading wheel in the corner of the screen. . onStartingUpdate (() => isUpdating = true ) . onFinishingUpdate (() => isUpdating = false ) // Save the results when updated . onUpdated ( newResults => results = newResults ) // Log any errors. . onErrored ( error => console . log ( error )) . start (); results will now contain up to date information. The returned listener is essential for cleaning up and avoiding excess requests.","title":"Listening for updates"},{"location":"js/js/#cleaning-up","text":"When the user navigates away from the code, you'll want to stop the client from listening. When you call start() , you get back a listener. Call listener.stop() to cancel any requests and stop the listening.","title":"Cleaning Up"},{"location":"js/js/#available-methods","text":"","title":"Available methods"},{"location":"js/js/#runs","text":"Interact with times that your jobs have ran","title":"Runs"},{"location":"js/js/#search-for-runs","text":"Request Response client . runs . search () . whereAlias ( 'job-alias' ) // Optional call to filter by alias. Can be called multiple times. . whereStatus ( 'failed' ) // Optional call to filter by status. Can be called multiple times. . send (); [{ alias : string ; // The alias of your job. class : string ; // The class of the job. percentage : number ; // The percentage of the way through the job we are. status : string ; // The status of the job. uuid : string ; // The UUID Laravel assigned to the job. parent : {...} | null ; // The parent of the job. This is filled in if a job failed and this is the retry. It has the same structure as this data structure. created_at : Date ; // When was the job status created. This is always the order in which the runs were queued. messages : [ // Any messages sent in the job { message : string ; // The message type : MessageType ; // The type of the message } ]; signals : [ // Signals sent to the job { signal : string ; // The signal sent created_at : Date ; // When the signal was sent handled_at : Date ; // When the signal was handled cancel_job : boolean ; // If the signal will/did cause the job to stop parameters : { key : value // User-defined parameters in the signal }; } ]; exception : { // The exception that caused the job to fail, or null if not an exception id : number ; // An ID for the exception previous : JobException | null ; // The previous thrown exception, or null if only one exception was thrown message : string ; // The exception message line : number ; // The line the error occurred on file : string ; // The file the error occurred in code : number ; // The code of the exception stack_trace : []; // The stack trace }; statuses : [ // A history of status changes for the job { status : Status ; // The status created_at : Date ; // When the status was set } ]; started_at : Date | null ; // When the job started processing finished_at : Date | null ; // When the job finished processing batch_id : number ; // The ID of the batch batch_id_uuid : string ; // The UUID of the batch that Laravel assigned id : number ; // An ID for the run tags : { // A list of tags the job has applied key : value }; has_payload : boolean ; // Whether we've stored the payload of the job connection_name : string | null ; // The name of the connection the job is stored on queue : string | null ; // The queue the job is in released_runs : [{...}] // Any times this run ran but was stopped by rate limiting middleware. This is an array of runs with the same structure as this data structure. }]","title":"Search for runs"},{"location":"js/js/#get-a-run-by-id","text":"Request Response client . runs . show ( 44 ) . send (); { alias : string ; // The alias of your job. class : string ; // The class of the job. percentage : number ; // The percentage of the way through the job we are. status : string ; // The status of the job. uuid : string ; // The UUID Laravel assigned to the job. parent : {...} | null ; // The parent of the job. This is filled in if a job failed and this is the retry. It has the same structure as this data structure. created_at : Date ; // When was the job status created. This is always the order in which the runs were queued. messages : [ // Any messages sent in the job { message : string ; // The message type : MessageType ; // The type of the message } ]; signals : [ // Signals sent to the job { signal : string ; // The signal sent created_at : Date ; // When the signal was sent handled_at : Date ; // When the signal was handled cancel_job : boolean ; // If the signal will/did cause the job to stop parameters : { key : value // User-defined parameters in the signal }; } ]; exception : { // The exception that caused the job to fail, or null if not an exception id : number ; // An ID for the exception previous : JobException | null ; // The previous thrown exception, or null if only one exception was thrown message : string ; // The exception message line : number ; // The line the error occurred on file : string ; // The file the error occurred in code : number ; // The code of the exception stack_trace : []; // The stack trace }; statuses : [ // A history of status changes for the job { status : Status ; // The status created_at : Date ; // When the status was set } ]; started_at : Date | null ; // When the job started processing finished_at : Date | null ; // When the job finished processing batch_id : number ; // The ID of the batch batch_id_uuid : string ; // The UUID of the batch that Laravel assigned id : number ; // An ID for the run tags : { // A list of tags the job has applied key : value }; has_payload : boolean ; // Whether we've stored the payload of the job connection_name : string | null ; // The name of the connection the job is stored on queue : string | null ; // The queue the job is in }","title":"Get a run by ID"},{"location":"js/js/#retry-a-run","text":"Request Response client . runs . retry ( 44 ) . send (); {}","title":"Retry a run"},{"location":"js/js/#send-a-signal","text":"Request Response client . runs . signal ( jobStatusId : number , // The ID of the run model signal : string , // The signal to send, e.g. 'cancel' cancel : boolean , // Whether to cancel the job when the signal runs. parameters : { key : value } // Parameters to pass to the job through the signal ) . send (); {}","title":"Send a signal"},{"location":"js/js/#jobs","text":"Interact with the jobs in your Laravel app","title":"Jobs"},{"location":"js/js/#search-for-jobs","text":"Request Response client . jobs . search () . send (); [{ class : string ; // The class of the job alias : string ; // The alias of the job count : number ; // The number of times this job has ran successful : number ; // The number of successful jobs failed : number ; // The number of failed jobs started : number ; // The number of started jobs queued : number ; // The number of queued jobs cancelled : number ; // The number of cancelled jobs failure_reasons : [ // The reasons the job has failed { message : 'Your error message' , count : 10 } ]; }] See the Run Show documentation for the structure of the job run","title":"Search for jobs"},{"location":"js/js/#show-a-job-by-aliasclass","text":"Request Response client . jobs . show ( 'my-job-alias-or-class' ) // Pass the job alias or the job class to retrieve the job. . send (); { class : string ; // The class of the job alias : string ; // The alias of the job count : number ; // The number of times this job has ran successful : number ; // The number of successful jobs failed : number ; // The number of failed jobs started : number ; // The number of started jobs queued : number ; // The number of queued jobs cancelled : number ; // The number of cancelled jobs failure_reasons : [ // The reasons the job has failed { message : 'Your error message' , count : 10 } ]; } See the Run Show documentation for the structure of the job run","title":"Show a job by alias/class"},{"location":"js/js/#batches","text":"Retrieve information about the batches that have ran through your queue system","title":"Batches"},{"location":"js/js/#search-for-batches","text":"Request Response client . batches . search () . send (); [{ count : number ; // The number of jobs in this batch batch_id : string ; // The UUID of this batch that Laravel assigned name : string | null ; // The name of this batch created_at : Date ; // When this batch was created queued : number ; // How many runs in the batch are queued started : number ; // How many runs in the batch are started failed : number ; // How many runs in the batch are failed succeeded : number ; // How many runs in the batch are succeeded cancelled : number ; // How many runs in the batch are cancelled }]","title":"Search for batches"},{"location":"js/js/#get-a-batch-by-id","text":"Request Response client . batches . show ( 24 ) // This is the ID of the batch from this package, and not the UUID. . send (); { count : number ; // The number of jobs in this batch batch_id : string ; // The UUID of this batch that Laravel assigned name : string | null ; // The name of this batch created_at : Date ; // When this batch was created queued : number ; // How many runs in the batch are queued started : number ; // How many runs in the batch are started failed : number ; // How many runs in the batch are failed succeeded : number ; // How many runs in the batch are succeeded cancelled : number ; // How many runs in the batch are cancelled }","title":"Get a batch by ID"},{"location":"js/snippets/","text":"JS Examples Since there are so many ways to use the job status API, we don't provide a Vue component or specific framework integrations. However, you can use the js tool in any js framework. This page has some snippets you can use to integrate job tracking with your Vue app. Show the user the progress of a podcast being uploaded A user uploads a podcast, and we show them the progress of it being uploaded Vue 2 <template> <div v-if=\"initialLoadOngoing\">Loading...</div> <div v-else-if=\"run !== null\"> <div v-if=\"updating\">Updating...</div> <div>Podcast status: {{run.status}}</div> <div>{{run.percentage}}% complete</div> <div v-if=\"run.messages.length > 0\"> <div>{{Upload Feedback: {{run.messages[run.messages.length - 1]}} | </div> </div> </div> <div v-else>Please upload a podcast</div> </template> <script> import {client} from '@tobytwigger/laravel-job-status-js'; export default { data() { return { initialLoadOngoing: false, updating: false, run: null, listenerId: null }; }, mounted() { this.listenerId = client.jobs.show('upload-podcast') .listen() .onStartingInitialLoad(() => this.initialLoadOngoing = true) .onFinishingInitialLoad(() => this.initialLoadOngoing = false) .onStartingUpdate(() => this.updating = true) .onFinishingUpdate(() => this.updating = false) .onUpdated(newRun => this.run = newRun) .onErrored(error => console.log(error)) .start(); }, beforeUnmount() { client.cleanup(this.listenerId); } } </script> Seeing the progress of a sync (multiple jobs) We want to show a user how all the 'Sync your cycle ride' jobs are progressing Vue 2 <template> <div v-if=\"initialLoadOngoing\">Loading...</div> <div v-else-if=\"job !== null\"> <div v-if=\"updating\">Updating...</div> <div>Queued: {{jobSummary.queued}}</div> <div>Running: {{jobSummary.started}}</div> <div>Finished: {{jobSummary.succeeded}}</div> <div>Cancelled: {{jobSummary.cancelled}}</div> <div>Failed: {{jobSummary.failed}}</div> </div> </template> <script> import {client} from '@tobytwigger/laravel-job-status-js'; export default { data() { return { initialLoadOngoing: false, updating: false, job: null, listenerId: null }; }, mounted() { this.listenerId = client.jobs.show('upload-podcast') .forUser(user().id) .listen() .onStartingInitialLoad(() => this.initialLoadOngoing = true) .onFinishingInitialLoad(() => this.initialLoadOngoing = false) .onStartingUpdate(() => this.updating = true) .onFinishingUpdate(() => this.updating = false) .onUpdated(newJob => this.job = newJob) .onErrored(error => console.log(error)) .start(); }, beforeUnmount() { client.cleanup(this.listenerId); }, computed: { jobSummary() { let statuses = {queued: 0, started: 0, failed: 0, succeeded: 0, cancelled: 0}; for(let run in this.job.runs) { statuses[run.status] += 1; } return statuses; } } } </script>","title":"Examples"},{"location":"js/snippets/#js-examples","text":"Since there are so many ways to use the job status API, we don't provide a Vue component or specific framework integrations. However, you can use the js tool in any js framework. This page has some snippets you can use to integrate job tracking with your Vue app.","title":"JS Examples"},{"location":"js/snippets/#show-the-user-the-progress-of-a-podcast-being-uploaded","text":"A user uploads a podcast, and we show them the progress of it being uploaded Vue 2 <template> <div v-if=\"initialLoadOngoing\">Loading...</div> <div v-else-if=\"run !== null\"> <div v-if=\"updating\">Updating...</div> <div>Podcast status: {{run.status}}</div> <div>{{run.percentage}}% complete</div> <div v-if=\"run.messages.length > 0\"> <div>{{Upload Feedback: {{run.messages[run.messages.length - 1]}} | </div> </div> </div> <div v-else>Please upload a podcast</div> </template> <script> import {client} from '@tobytwigger/laravel-job-status-js'; export default { data() { return { initialLoadOngoing: false, updating: false, run: null, listenerId: null }; }, mounted() { this.listenerId = client.jobs.show('upload-podcast') .listen() .onStartingInitialLoad(() => this.initialLoadOngoing = true) .onFinishingInitialLoad(() => this.initialLoadOngoing = false) .onStartingUpdate(() => this.updating = true) .onFinishingUpdate(() => this.updating = false) .onUpdated(newRun => this.run = newRun) .onErrored(error => console.log(error)) .start(); }, beforeUnmount() { client.cleanup(this.listenerId); } } </script>","title":"Show the user the progress of a podcast being uploaded"},{"location":"js/snippets/#seeing-the-progress-of-a-sync-multiple-jobs","text":"We want to show a user how all the 'Sync your cycle ride' jobs are progressing Vue 2 <template> <div v-if=\"initialLoadOngoing\">Loading...</div> <div v-else-if=\"job !== null\"> <div v-if=\"updating\">Updating...</div> <div>Queued: {{jobSummary.queued}}</div> <div>Running: {{jobSummary.started}}</div> <div>Finished: {{jobSummary.succeeded}}</div> <div>Cancelled: {{jobSummary.cancelled}}</div> <div>Failed: {{jobSummary.failed}}</div> </div> </template> <script> import {client} from '@tobytwigger/laravel-job-status-js'; export default { data() { return { initialLoadOngoing: false, updating: false, job: null, listenerId: null }; }, mounted() { this.listenerId = client.jobs.show('upload-podcast') .forUser(user().id) .listen() .onStartingInitialLoad(() => this.initialLoadOngoing = true) .onFinishingInitialLoad(() => this.initialLoadOngoing = false) .onStartingUpdate(() => this.updating = true) .onFinishingUpdate(() => this.updating = false) .onUpdated(newJob => this.job = newJob) .onErrored(error => console.log(error)) .start(); }, beforeUnmount() { client.cleanup(this.listenerId); }, computed: { jobSummary() { let statuses = {queued: 0, started: 0, failed: 0, succeeded: 0, cancelled: 0}; for(let run in this.job.runs) { statuses[run.status] += 1; } return statuses; } } } </script>","title":"Seeing the progress of a sync (multiple jobs)"}]}